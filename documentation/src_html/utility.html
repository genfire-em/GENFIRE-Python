<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>..//GENFIRE/utility</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code><font color="orange">from </font>__future__ <font color="orange">import </font>division<br><font color="orange">import </font>numpy as np<br><font color="orange">import </font>pyfftw<br><font color="orange">from </font>scipy.interpolate <font color="orange">import </font>RegularGridInterpolator<br>PI = np.pi<br><br><br><br>## hermitianSymmetrize ##<br><br>## Applies Hermitian symmetry to "input". If one symmetry mate is not equal to the complex conjugate of the other<br>## their average is taken. If only one of them exists (is nonzero), then the one value is used. If neither exists<br>## the value remains 0. In terms of implementation, this function produces Hermitian symmetry by adding the object<br>## to its complex conjugate with the indices reversed. This requires the array to be odd, so there is also a check<br>## to make the array odd and then take back the original size at the end, if necessary.<br><br>## Author: AJ Pryor<br>## Jianwei (John) Miao Coherent Imaging Group<br>## University of California, Los Angeles<br>## Copyright (c) 2016. All Rights Reserved.<br><font color="orange">def </font>hermitianSymmetrize(input):<br><br>    startDims = np.shape(input) # initial dimensions<br><br>    # remember the initial dimensions for the end<br>    dimx = startDims[0]<br>    dimy = startDims[1]<br>    dimz = startDims[2]<br>    flag = <font color="orange">False </font># flag to trigger copying to new odd dimensioned array<br><br>    #check if any dimension is odd<br>    <font color="orange">if </font>dimx % 2 == 0:<br>        dimx += 1<br>        flag = <font color="orange">True<br></font><br>    <font color="orange">if </font>dimy % 2 == 0:<br>        dimy += 1<br>        flag = <font color="orange">True<br></font><br>    <font color="orange">if </font>dimz % 2 == 0:<br>        dimz += 1<br>        flag = <font color="orange">True<br></font><br>    <font color="orange">if </font>flag: # if any dimensions are even, create a new with all odd dimensions and copy input<br>        newInput = np.zeros((dimx,dimy,dimz), dtype=complex) #new array<br>        newInput[:startDims[0], :startDims[1], :startDims[2]] = input # copy values<br>        numberOfValues = (newInput != 0).astype(float) #track number of values for averaging<br>        newInput = newInput + np.conj(newInput[::-1, ::-1, ::-1]) # combine Hermitian symmetry mates<br>        numberOfValues = numberOfValues + numberOfValues[::-1, ::-1, ::-1] # track number of points included in each sum<br><br>        newInput[numberOfValues != 0] /= numberOfValues[numberOfValues != 0] # take average where two values existed<br>        newInput[np.isnan(newInput)] = 0 # Shouldn't be any nan, but just to be safe<br><br>        return newInput[:startDims[0], :startDims[1], :startDims[2]] # return original dimensions<br><br><br>    else: # otherwise, save yourself the trouble of copying the matrix over. See previous comments for line-by-line<br>        numberOfValues = (input != 0).astype(int)<br>        input += np.conjugate(input[::-1, ::-1, ::-1])<br>        numberOfValues += numberOfValues[::-1, ::-1, ::-1]<br>        input[numberOfValues != 0] /= numberOfValues[numberOfValues != 0]<br>        input[np.isnan(input)] = 0<br>        return input<br><br><br><br><br>## smooth3D ##<br><br>## Smooths the real space object "object" by applying a Gaussian filter with standard<br>## deviation determined by "resolutionCutoff" which is a parameter expressed as a fraction<br>## of Nyquist frequency that determines the point at which the Gaussian filter decreases<br>## by 1/e<br><br>## Author: AJ Pryor<br>## Jianwei (John) Miao Coherent Imaging Group<br>## University of California, Los Angeles<br>## Copyright (c) 2016. All Rights Reserved.<br><br><font color="orange">def </font>smooth3D(object,resolutionCutoff):<br>    dims = np.shape(object)<br>    <font color="orange">if </font>dims[2] == 1:<br>        raise Exception('This is not a 3D object, use smooth2D instead.')<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # These  next few lines are easier to read, but in the actual code I just directly<br>    # place the np.arange terms in to avoid creating unnecessary variables<br>    # Xvec = np.arange(0,dims[0])-Xcenter<br>    # Yvec = np.arange(0,dims[1])-Ycenter<br>    # Zvec = np.arange(0,dims[2])-Zcenter<br>    # xx, yy, zz = np.meshgrid(Xvec, Yvec, Zvec)<br><br>    xx, yy, zz = np.meshgrid(np.arange(0,dims[0])-Xcenter, np.arange(0,dims[1])-Ycenter, np.arange(0,dims[2])-Zcenter)<br>    sigma  = dims[0]/2*resolutionCutoff<br><br>    #construct the filter and normalize<br>    K_filter = np.exp(-(((xx)**2 + (yy)**2 + (zz) **2)/(2*sigma*sigma)))<br>    K_filter /= np.max(np.max(np.max(abs(K_filter))))<br><br>    # take FFT and multiply by filter<br>    kbinned = pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.fftn(object,overwrite_input=True)) * K_filter<br><br>    # Assuming the input is real, the output will be approximately real, but will have some<br>    # tiny imaginary part due to rounding errors. This function would work for smoothing a<br>    # complex object, but this return statement would need to be modified<br>    return np.real(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(kbinned)))<br><br><br><br>## smooth2D ##<br><br>## Smooths the 2D real space object "object" by applying a Gaussian filter with standard<br>## deviation determined by "resolutionCutoff" which is a parameter expressed as a fraction<br>## of Nyquist frequency that determines the point at which the Gaussian filter decreases<br>## by 1/e<br><br>## Author: AJ Pryor<br>## Jianwei (John) Miao Coherent Imaging Group<br>## University of California, Los Angeles<br>## Copyright (c) 2016. All Rights Reserved.<br><br><font color="orange">def </font>smooth2D(object,resolutionCutoff):<br>    dims = np.shape(object)<br>    <font color="orange">if </font>len(dims)>2:<br>        raise Exception('This is a 3D object, use smooth3D instead.')<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br><br>    # These  next few lines are easier to read, but in the actual code I just directly<br>    # place the np.arange terms in to avoid creating unnecessary variables<br>    # Xvec = np.arange(0,dims[0])-Xcenter<br>    # Yvec = np.arange(0,dims[1])-Ycenter<br>    # xx, yy = np.meshgrid(Xvec, Yvec)<br><br>    xx, yy = np.meshgrid(np.arange(0,dims[0])-Xcenter, np.arange(0,dims[1])-Ycenter)<br>    sigma  = dims[0]/2*resolutionCutoff<br><br>    #construct the filter and normalize<br>    K_filter = np.exp(-(((xx)**2 + (yy)**2)/(2*sigma*sigma)))<br>    K_filter /= np.max(np.max(np.max(abs(K_filter))))<br><br>    # take FFT and multiply by filter<br>    kbinned =  pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.fftn(object,overwrite_input=True)) * K_filter<br><br>    # Assuming the input is real, the output will be approximately real, but will have some<br>    # tiny imaginary part due to rounding errors. This function would work for smoothing a<br>    # complex object, but this return statement would need to be modified<br>    return np.real(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(kbinned)))<br><br><br><br><font color="orange">def </font>calculateProjection_interp(modelK, phi, theta, psi):<br><br>    # projection = None<br>    dims = np.shape(modelK)<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # X, Y, Z = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), 0)<br>    phi *= PI/180<br>    theta *= PI/180<br>    psi *= PI/180<br><br>    R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>    [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>    [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br><br>    R = R.T<br><br>    # build coordinates of 3D FFT<br>    # kx, ky, kz = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), np.arange(1,dims[2]-Zcenter))<br><br>    kx = np.arange(0, dims[0])-Xcenter<br>    ky = np.arange(0, dims[1])-Ycenter<br>    kz = np.arange(0, dims[2])-Zcenter<br><br>    # construct interpolator function that does the actual computation<br>    interpolator = RegularGridInterpolator((kx, ky, kz), modelK, bounds_error=False, fill_value=0)<br><br>    # build coordinates of the slice we want to calculate<br>    kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br><br>    # rotate coordinates<br>    rotKCoords = np.zeros([3, np.size(kx_slice)])<br>    rotKCoords[0, :] = np.reshape(kx_slice, [1, np.size(kx_slice)])<br>    rotKCoords[1, :] = np.reshape(ky_slice, [1, np.size(ky_slice)])<br>    rotKCoords[2, :] = np.reshape(kz_slice, [1, np.size(kz_slice)])<br>    rotKCoords = np.dot(R, rotKCoords)<br><br>    projection = interpolator(rotKCoords.T)<br>    projection = np.reshape(projection, [dims[0], dims[1]], order='F')<br><br><br>    return np.real(pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(projection))))<br><br><br><font color="orange">def </font>getProjectionInterpolator(modelK):<br>    dims = np.shape(modelK)<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    kx = np.arange(0, dims[0])-Xcenter<br>    ky = np.arange(0, dims[1])-Ycenter<br>    kz = np.arange(0, dims[2])-Zcenter<br><br>    # construct interpolator function that does the actual computation<br>    return RegularGridInterpolator((kx, ky, kz), modelK, bounds_error=False, fill_value=0)<br><br><font color="orange">def </font>calculateProjection_interp_fromInterpolator(interpolator, phi, theta, psi, dims):<br>    # X, Y, Z = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), 0)<br>    phi *= PI/180<br>    theta *= PI/180<br>    psi *= PI/180<br><br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>    [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>    [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br><br>    R = R.T<br><br>    # build coordinates of the slice we want to calculate<br>    kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br><br>    # rotate coordinates<br>    rotKCoords = np.zeros([3, np.size(kx_slice)])<br>    rotKCoords[0, :] = np.reshape(kx_slice, [1, np.size(kx_slice)])<br>    rotKCoords[1, :] = np.reshape(ky_slice, [1, np.size(ky_slice)])<br>    rotKCoords[2, :] = np.reshape(kz_slice, [1, np.size(kz_slice)])<br>    rotKCoords = np.dot(R, rotKCoords)<br><br>    projection = interpolator(rotKCoords.T)<br>    projection = np.reshape(projection, [dims[0], dims[1]], order='F')<br><br><br>    return np.real(pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(projection))))<br><br># def calculateProjection_interp_pyfftw(modelK, phi, theta, psi):<br>#<br>#     # projection = None<br>#     dims = np.shape(modelK)<br>#     Xcenter = round(dims[0]//2)<br>#     Ycenter = round(dims[1]//2)<br>#     Zcenter = round(dims[2]//2)<br>#<br>#     # X, Y, Z = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), 0)<br>#     phi *= PI/180<br>#     theta *= PI/180<br>#     psi *= PI/180<br>#<br>#     R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>#     [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>#     [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br>#<br>#     R = R.T<br>#<br>#     # build coordinates of 3D FFT<br>#     # kx, ky, kz = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), np.arange(1,dims[2]-Zcenter))<br>#<br>#     kx = np.arange(0, dims[0])-Xcenter<br>#     ky = np.arange(0, dims[1])-Ycenter<br>#     kz = np.arange(0, dims[2])-Zcenter<br>#<br>#     # construct interpolator function that does the actual computation<br>#     interpolator = RegularGridInterpolator((kx, ky, kz), modelK, bounds_error=False, fill_value=0)<br>#<br>#     # build coordinates of the slice we want to calculate<br>#     kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br>#<br>#     # rotate coordinates<br>#     rotKCoords = np.zeros([3, np.size(kx_slice)])<br>#     rotKCoords[0, :] = np.reshape(kx_slice, [1, np.size(kx_slice)])<br>#     rotKCoords[1, :] = np.reshape(ky_slice, [1, np.size(ky_slice)])<br>#     rotKCoords[2, :] = np.reshape(kz_slice, [1, np.size(kz_slice)])<br>#     rotKCoords = np.dot(R, rotKCoords)<br>#<br>#     projection = interpolator(rotKCoords.T)<br>#     projection = np.reshape(projection, [dims[0], dims[1]], order='F')<br>#<br>#<br>#     return np.real( pyfftw.interfaces.numpy_fft.fftshift( pyfftw.interfaces.numpy_fft.ifftn( pyfftw.interfaces.numpy_fft.ifftshift(projection))))<br><br></code></body>
    </html>